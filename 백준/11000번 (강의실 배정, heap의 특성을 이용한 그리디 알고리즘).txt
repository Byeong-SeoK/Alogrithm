import heapq
#heapq를 사용하는 이유
#일반적인 배열이나 큐, 덱을 사용하면 배열에서 특정 값에 대한 탐색 시간이 O(N)이다.
#그러나 heapq를 사용하면 특정 값에 대한 탐색 시간이 O(logN)으로 줄어든다.
#즉, 이 문제에서 heap은 정렬이나 우선순위가 있는 데이터를 다루기 위함이 아니라
#특정 값에 대한 탐색을 최대한 빠르게 하기 위해서 사용한다.
#또한 heap은 기본적으로 최소힙이므로 항상 가장 작은 값이 0번째에 오게된다.
#그러므로 새로운 임의의 값을 넣어도 자동으로 정렬이 되어 항상 0번쩨에는
#가장 빨리 끝나는 수업의 시각이 들어가게 된다.
#그래서 별다른 정렬없이 단순히 이후 수업의 시작 시간과 비교하면 된다.

N = int(input())
subject = [] #각 수업당 [시작시간, 끝나는 시간]을 받는 배열이다.

for _ in range(0, N):
    start, end = map(int, input().split())
    subject.append((start, end))

subject.sort()
#탐색하기 편하도록 입력받은 수업 시간들을 오름차순으로 정렬한다.

room = [] #강의실을 받는 배열 즉, 이 배열의 길이가 강의실의 총 개수에 해당한다.
heapq.heappush(room, subject[0][1])
#가장 처음에 시작하는 수업은 항상 새로운 강의실이 필요한 상황이다.
#그러므로 room이라는 heap은 항상 subject[0][1]이 들어가야한다.
#이 room이라는 배열은 각 수업의 끝나는 시간을 값으로 가지고 있는 배열이다.
#그러므로 이후 수업의 시작 시간과 비교하여 새로운 강의실을 할당할지 말지를 결정할 수 있다.
#그리고 heap이 최소힙으로 자동으로 정렬된다는 점을 이용하면 비교 이전에 별다느 정렬을 안 넣어도 된다.

for i in range(1, len(subject)):
    if(subject[i][0] < room[0]): #다음 수업의 시작점이 이전 수업 끝나는 시간보다 작은 경우 새로운 강의실이 필요하다.
        heapq.heappush(room, subject[i][1]) #강의실을 추가해야하므로 room 힙에 새로운 수업의 끝나는 시간을 넣는다.

    else: #다음 수업의 시작점이 이전 수업 끝나는 시간보다 크거나 같은 경우는 이전 수업 강의실을 그대로 사용하면 된다.
        heapq.heappop(room) #기존의 강의실에 새로운 수업을 진행하게 되므로 이전 수업을 빼고 새로운 수업을 넣는다.
        heapq.heappush(room, subject[i][1]) #그래서 새로운 수업의 끝나는 시간을 넣으면 된다.

print(len(room))