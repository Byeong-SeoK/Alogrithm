import sys
input = sys.stdin.readline

T, W = map(int, input().split())

tree = [0]
for _ in range(0, T):
    tree.append(int(input()))

dp = [[0]*(W+1) for _ in range(0, T+1)]
#dp배열은 2차원 배열로 가로는 자두가 떨어지는 트리에 해당하고
#세로는 사람이 움직인 횟수에 해당한다.
#그래서 예제에서의 7, 2로 보면 가로는 총 8개 행이 있고 세로는 총 3개의 열이 있다.
#각각 1개씩 더 많은 이유는 아무것도 없는 0일 때의 상태를 추가했기 때문이다.
#즉, 각 가로는 각 시점에서의 자두가 떨어지는 나무의 위치를 의미하고
#세로는 몇 번 움직였을 때인지를 의미한다.
#그래서 0은 한번도 움직이지 않았을 때의 각 나무에서의 최대값을 가지고 있고
#1은 한번 움직였을 때의 각 나무에서의 최대값을 가지고 있는 것이다.
#즉, W는 움직임의 제약조건이라 보기보다는 각 나무 일 때 i번 움직인 상황이라는 상황 조건으로 보는 것이 좋다.

for i in range(1, T+1):
    #트리에 하나씩 접근한다.
    #이때 사람이 가장 처음에 있는 나무 위치를 1번 나무로 임의로 지정한다.
    #아래의 분기문은 0번 이동하는 모든 나무일 때의 상황에 대해 처리하는 것이고
    #그 아래의 for문은 n번 이동하는 모든 나무일 때의 상황에 대해 처리하는 것이다.

    if(tree[i] == 1):
        #tree가 1이고 이전에 위치해있던 나무도 1인 경우 자두를 먹으므로 +1을 한다.
        #그리고 이동할 필요가 없으므로 움직이지 않았다는 의미이기에
        #dp에서 움직이지 않았을 때의 값을 가지고 있는 i-1번째의 행의 0번째 열에 +1을 한다.
        dp[i][0] = dp[i-1][0]+1
    else:
        dp[i][0] = dp[i-1][0]
        #2번 나무인 경우 1번 나무에서 2번 나무로 이동을 해야한다.
        #하지만 0번 움직이는 경우에는 나무가 달라도 움직이지 않으므로 자두를 먹지 못한다.
        #그래서 이전의 값을 그대로 가져다 현재에 넣으면 된다.
        #이동에 대한 것들은 분기문 바깥 for문에서 다룬다.

    for j in range(1, W+1):
        #이제 이동할 때에 대한 로직을 처리해야하므로 0번 이동하는 상황에 대해서는 접근할 필요가 없다.
        #그래서 for문의 범위가 0번 부터가 아닌 dp의 1번 열부터 접근하는 것이다.
        #아래 조건문의 각 dp로직의 j-1과 j만 비교하는 이유는 j+1에서 j로 이동 횟수가 적어지는 경우는 없기 때문이다.

        if(tree[i] == 2 and j%2 == 1):
            #단순히 해석을 하면 자두가 떨어지려는 나무와 사람의 위치가 2번으로 같은 경우이다.
            #시작하는 나무가 항상 1번 나무이다. 그러므로 2번 나무일 경우 이동해야한다.
            #또 0번 이동 혹은 2번 이동과 같이 짝수 번에 이동할 때는 항상 1번 나무에 위치한다.
            #그러므로 홀수번 이동했을 때 2번 나무가 되므로 분기문의 조건은 2번 나무이자 홀수번 이동한 상황이어야 한다.

            dp[i][j] = max(dp[i-1][j-1], dp[i-1][j])+1
            #이때 이전 나무에 대한 값 dp[i-1] 중에서 j-1번째와 j번째
            #즉, 한번 이동을 해서 2번 나무가 되는 경우의 값과 원래 2번 나무여서 이동하지 않아도 되는 경우의 값을
            #서로 비교해서 그 중에 더 큰 값에 대해 +1을 하여 dp[i][j]에 넣는다.

        elif(tree[i] == 1 and j%2 == 0):
            #단순히 해석을 하면 자두가 떨어지려는 나무와 사람의 위치가 1번으로 같은 경우이다.
            #시작하는 나무가 항상 1번 나무이다. 그러므로 1번 나무일 경우 이동을 할 필요가 없다.
            #다만, 2번 나무에서 1번 나무로 이동하는 경우가 있으므로 그 경우와 이동하지 않을 때의 경우를 비교해야한다.
            #그래서 현재 1번 나무인 경우는 짝수번 이동했을 때의 경우와 그 짝수번의 -1 인 경우를 비교한다.

            dp[i][j] = max(dp[i-1][j-1], dp[i-1][j])+1
            #위의 분기의 조건과 같이 j번째는 현재 1번 나무에 계속 있는 경우를 의미하고
            #j-1번째는 2번 나무에서 1번 나무로 이동하는 경우를 의미한다.
            #그래서 두가지 경우를 비교해서 더 큰 값에 대해 +1을 하도록 한다.

        else:
            #이 경우는 자두가 떨어지려는 나무가 1인데 j%2 == 1이거나 자두가 떨어지려는 나무가 2인데 j%2 == 0인 경우이다.
            #즉, 떨어지려는 나무의 번호와 사람의 위치가 다른 경우에 해당한다.
            #이때는 이전 단계의 홀수번 이동했을 때 값과 짝수번 이동했을 때의 값을 비교하여 더 큰 것을 넣는다.
            #왜냐하면 위치가 다르기 때문에 자두를 먹을 수 없기 때문이다.

            dp[i][j] = max(dp[i-1][j-1], dp[i-1][j])

print(max(dp[T]))
