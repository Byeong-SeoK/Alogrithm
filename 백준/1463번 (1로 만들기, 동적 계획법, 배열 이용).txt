"""
상향식 동적계획법으로 해당 문제를 푼다.
이때 상향식 동적계획법이라는 것은 1부터 입력받은 수 N으로
올라가면서 연산을 하는 것을 의미한다.
반대로 하향식 동적계획법이라는 것은 입력받은 수 N부터
1까지 아래로 내려가면서 연산을 하는 것을 의미한다.
"""

N = int(input())
count = [0] * (N+1)
#배열의 index와 다르게 수는 1부터 시작하므로
#배열의 크기를 N+1로 잡아서 N까지 count 배열에서 
#다 커버할 수 있도록 만든다.

for i in range(2, N+1):
    #반복문을 2부터 시작하는 이유는 배열의 index가 실제 숫자를 의미하는데
    #이때 0번째 index 즉, 0은 1을 문제에서 언급한 3가지 방법을 이용하여
    #만들수 없고 1번째 index 즉, 1은 1이므로 문제에서 언급한 3가지 방법을
    #이용하지 않아도 이미 1이므로 0번째, 1번째 index모두 0이라는 값을 갖는다.
    #그러므로 굳이 0, 1번째 index를 반복문을 통해 접근할 필요가 없다.
    #그리고 2부터 처음으로 2-1 = 1 or 2//2 = 1 이렇게 1번의 연산을 통해
    #1로 만들 수 있으므로 여기서부터 접근한다.
    
    num = 1000000000
    #더 작은 값이 무엇인지 비교를 하기 위해서 임의의 큰 수를 지정한 것이다.
    
    """
    N = 10이라고 하고 이를 1로 줄여나가는 상황이라고 생각해보자
    다음에 올 수 있는 경우로는 10/2 = 5인 경우와 10-1 = 9인 경우이다.
    결국 이는 배열의 10번째 index에 들어갈 값은 배열의 5번째 index에 들어간 값
    혹은 9번째 index에 들어간 값 중 더 작은 값에 해당한다.
    따라서 10 -> 9 -> 3 -> 1이므로 10은 9번째 index의 값과 3번째 index의 값을
    합산한 값이 들어가게 된다.
    """
    
    if(i % 3 == 0):
        num = min(num, count[i//3])
        #3으로 떨어지는 경우 num과 count배열의 i//3번째 있는 것을 비교하여
        #어떤 것이 더 작은지를 구하고 그 값을 num에 넣는다.
        
    if(i % 2 == 0):
        num = min(num, count[i//2])
        #2로 떨어지는 경우 num과 count배열의 i//2번째 있는 것을 비교하여
        #어떤 것이 더 작은지를 구하고 그 값을 num에 넣는다.
    
    #위의 과정을 거치는 이유는 예를 들어 4를 1로 만든다고 할 때의 경우의 수를 세면
    #4를 1로 만들기 위한 방법은 2를 1로 만들기 위한 방법과 1을 1로 만들기 위한 방법을 더한것과 같다.
    #즉, 4 -> 2 -> 1 과정이기 때문에 위의 논리가 적용되는 것이다.
    
    count[i] = min(count[i-1], num)+1
    #위 코드는 -1을 해야하는 경우와 아닌 경우를 비교하기 위해서 있는 것이다.
    #즉, 예를 들어 N = 10이라고 하고 이를 1로 만드려고자 한다.
    #10을 1로 만드는 방법에는 10 -> 9 -> 3 -> 1 / 10 -> 5 -> 4 -> 2 -> 1
    #이렇게 2가지 경우가 있다. 예를 들어 i가 10인 상황에서 비교하는 두 값은
    #count[9]와 num = count[5]인 상황을 비교할 것이다.
    #그리고 어느쪽이 더 작든 9 -> 10 / 5 -> 10은 항상 1가지 경우이므로
    #더 작은 쪽에 위의 경우 1을 더하여 count[10]에 더한 값을 넣는다.
        
print(count[N])