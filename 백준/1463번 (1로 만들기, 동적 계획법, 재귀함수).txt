import sys
read = sys.stdin.readline

N = int(read())
cache = {1: 0, 2: 1}

def dp(n):
    if n in cache:
        return cache[n]
	
    # 핵심 코드
    cnt = 1 + min(dp(n//3) + n%3, dp(n//2) + n%2)
    #1을 더하는 이유는 3과 2로 나누어지지 않는 경우 항상 1을 빼야하기 때문이다.
    cache[n] = cnt
    return cnt
    
print(dp(N))



============ 설명 =============
리스트 대신 딕셔너리를 사용해서 값을 찾는 연산 속도를 줄일 수 있다.
재귀함수를 사용한다.
캐시에 값이 있는경우 값을 반환하고
핵심코드를 보면... 재귀함수에 각각 3과 2로 나눈 몫에 나머지를 더해서 최솟값을 구한다.
 

핵심코드 풀이
코드만 보면... 나머지값을 왜 더하는지 이해 안될 수 있다. 저도 이해하는데 시간이 오래 걸렸는데요... 
나머지값을 더하는 이유는 7 이나 11 처럼 2와 3으로 나눌 수 없는 경우 무조건 1을 1번 이상 빼고 진행을 하게됩니다.

2로 나누려고하면 나머지가 1
3으로 나누려고하면 나머지가 1, 2
2와 3의 배수가 아닌 숫자의 규칙은 위와 같습니다. 그래서 이런 경우 2가지 분기를 타게 됩니다.

 

 

※ 예시 N=7 인 경우 3과 2로 나눴을 때 나머지가 모두 1

해당 경우 3이든 7이든 -1을 한번씩 연산하고 진행해야 하기 때문에 나머지 1을 더해주는 것은 쉽게 이해가 된다.

 

 

※ 예시 N=11 인 경우 3과 2로 나눴을 때 나머지가 각각 2와 1

해당 경우는 두가지 루트로 나눠서 진행하겠다고 생각하시면 될 것 같습니다.

 -1을 두번 해서 3으로 나누려는 루트
-1을 한번 해서 2로 나누려는 루트
그림으로 예시를 보면 아래와 같습니다.


11에서 9로 가서 3을 나누는 루트로... 2번의 -1 연산을 해야하기 때문에 나머지인 2를 더하고

11에서 10으로 가서 2로 나누는 루트로... 1번의 -1 연산을 해야하기 때문에 나머지인 1을 더하는 원리입니다.