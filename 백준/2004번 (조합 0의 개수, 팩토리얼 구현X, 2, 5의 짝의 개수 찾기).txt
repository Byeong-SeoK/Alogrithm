N, K = map(int, input().split())

"""
두 수에 대해 각 수의 약수에 5와 2가 각각 몇 개씩 있는지 확인한다.
그리고 5와 2의 개수를 이용해서 0의 개수가 몇 개가 있는지 구하는 것이다.
직접 조합을 만들어서 구하면 시간초과가 발생한다.
예를들어 25 12에서는 각각 5: 2, 2: 0 / 5: 0, 2: 2 이므로
최종 값의 0의 개수는 2개가 된다.
단 이때, 5와 2중 적은 쪽의 숫자가 최종 값의 0의 개수가 된다.

아래의 check 함수 설명
a를 더하는 이유
a = a//b를 하였고 이때 a의 값은 a에서 a//b범위까지의
찾을 수 있는 b의 개수에 해당한다.
8! = 8 7 6 5 4 3 2 1 => 2가 나오는 횟수 7번이다

왜냐
8 = 2x2x2

6 = 2x3

4 = 2x2

2 = 2x1

으로 2가 7번나온다.

제곱수인 4는 2가 2번

3제곱수인 8은 2가 3번 나오는 것을 알 수있다.


여기서 알수있는것이 먼저 8 7 6 5 4 2 1에서 2의 배수의 갯수를 구한다. 8/2 = 4

다음으로 제곱수에 대해서 배수를 구한다. 8/(2*2) = 2

다음으로 세제곱수에 대해서 배수를 구한다. 8/(2*2*2) = 1

즉 4 + 2 + 1이란 것이다.
"""

def check(a, b):
    count = 0
    while a != 0:
        a = a // b
        count = count + a
        # 이 부분에 대한 설명은 위의 설명을 참조하자

    return count


result = min((check(N, 5)-check(K, 5)-check(N-K,5)), (check(N,2)-check(K,2)-check(N-K,2)))
"""
위 result가 0의 개수를 담고 있는 변수인데 저렇게 구해야하는 이유
우선 조합이라는 것은 N!을 K!과 (N-K)!으로 나누는 것이다.
그러므로 결과 값의 0의 개수는 N!, K!, (N-K)!에 영향을 받는다.
따라서 최종 결과 값의 0의 개수는 N!의 0의 개수에서 K!과 (N-K)!의 0의 개수를 빼는 것과 같다.
이때 0의 개수를 구하려면 2, 5의 짝을 이루는 개수를 구하는 것이므로 위의 논리에 의해
N!의 2, 5의 개수에서 K!과 (N-K)!의 2, 5의 개수를 빼는 것과 같다.
그리고 2, 5 개수 중 최솟값을 기준으로 0의 개수가 정해진다. 
"""
print(result)