import sys
input = sys.stdin.readline

N, T = map(int, input().split())
#N은 단원의 개수, T는 공부할 수 있는 총 시간이다.

time = [0]
score = [0]
for _ in range(0, N):
    t, s = map(int, input().split())

    time.append(t)
    score.append(s)


dp = [[0 for _ in range(0, T+1)] for _ in range(0, N+1)]
#dp배열은 i개 단원 중에서 j 시간을 투자하여 얻을 수 있는 최대 점수를 가지고 있는 배열이다.
#즉, dp배열의 행은 단원의 수를 의미하고 행은 각 단원을 공부할 때 드는 시간이다.
#그래서 dp의 행은 단원의 수이고 열은 0부터 T+1까지의 각 시간 값에 해당한다.

for i in range(1, N+1):
    #i는 score배열의 각 단원마다 얻을 수 있는 배점에 접근하는 index이다.
    #왜냐하면 N은 단원의 수 값을 받는 변수이기 때문이다.
    #그래서 i가 1일 때는 1번째 과목을 공부하는 동안 T만큼 시간이 지날 때 얻을 수 있는 배점이
    #dp배열 안에 저장되는 것이고 2번째 과목때 이전의 값을 사용하려면 i-1번째에 접근하면 된다.

    for j in range(1, T+1):
        #j는 index가 아니라 각 시간의 값에 해당한다.
        #그래서 이 for문은 time배열의 각 index에 접근하는 것이 아니라
        #진짜 각 시간 값에 접근하는 것이다.
        #그래서 j가 0이면 0시간을 의미하는 것이고 T이면 T시간을 의미하는 것이다.

        if(j >= time[i]):
            #j가 각 시간을 의미하는 것이므로 j가 time[i]보다 큰 상황이라는 뜻은
            #for문으로 각 j에 쭉 접근하다가 i번째 단원을 공부하는데 걸리는 시간
            #time[i]보다 값이 커질 때 해당 단원의 배점만큼은 가져갈 수 있으므로
            #그 배점의 값을 dp배열에 추가하는 것이다.
            #그리고 이 time[i] 이후로도 계속해서 j가 time[i]보다 더 큰 값을 가지므로
            #그 이후 시간에도 time[i]때 가져간 배점을 계속해서 가져갈 수 있다.

            dp[i][j] = max(dp[i-1][j], dp[i-1][j-time[i]]+score[i])
            #이때 time[i]만큼 공부 시간이 들기 때문에 j-time[i]인 위치의 배점 값에 score[i]를 더해야 한다.
            #당연히 그래야하는 이유가 j는 시간 값을 의미하고 해당 과목의 배점을 추가하려면 time[i]만큼
            #새로이 값을 추가해야한다. 그러므로 현재에 있던 시간 j값인 아닌 j-time[i]에 time[i]을
            #추가하는 것으로 새로운 score값을 갖도록 해야한다.
            #그리고 이때 새로이 얻은 값과 이전의 값을 비교하여 더 큰 값으로 바꾼다.

        else:
            #현재의 시간이 아직 과목을 공부하는데 드는 시간보다 작으므로
            #과목을 공부하는데 드는 score를 추가할 수 없고 이전의 값을 넣어야 한다.
            dp[i][j] = dp[i-1][j]

print(dp[N][T])

