stair = [0, 9] #각 자리 수에 해당하는 계단 수 총 개수를 받는 배열
case = [1, 2, 2, 2, 2, 2, 2, 2, 2, 1]
#초기 배열 상태는 2자리 수에서의 계단 수를 받는 배열이다.
#동적계획법을 어떻게 적용하였는지
"""
배열1: 0 9 17 32
배열2: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
2값:   1, 2, 2, 2, 2, 2, 2, 2, 2, 1
3값:   2[1], 2[0]+2[2], 2[1]+2[3], ~~~ 2[7]+2[9], 2[8]
--> 0번째 index에서 2값은 01 1개
--> 0번째 index에서 3값은 010 012 2개
위의 원리로 동적 계획법을 진행한다.
아래 숫자의 개수를 대입하여 계산해보면 위 식의 성립 여부를 알 수 있다.

2

10 12 //2
21 23 //2
32 34 //2
43 45 //2
54 56 //2
65 67 //2
76 78 //2
87 89 //2 
98     //1

3

101
121 123 //3
210 212
232 234 //4
321 323
343 345 //4
432 434
454 456 //4
543 545
565 567 //4
654 656
676 678 //4
765 767
787 789 //4
876 878
898	   //3
987 989 //2
"""

N = int(input())
if(N == 1):
    print(9)
elif(N == 2):
    print(17)
else:
    loop = 2
    #case배열이 2자리 수의 계단 수 값을 가지고 있으므로 loop 횟수가 이미 2번 돌았다고 생각할 수 있다.
    while loop < N:
        temp = []
        # 이 배열은 case 배열의 값을 한번에 바꾸기 전에 임시로 값을 받는 배열이다.
        # 즉, case 배열이 동적 계획법에 의해 값이 index 마다 달라질텐데
        # 이 값의 수정을 한번에 하기 위해 임시적으로 들고 있는 배열이다.

        for i in range(0, len(case)):
            if(i == 0):
                temp.append(case[i+1])
            elif(i == len(case)-1):
                temp.append(case[i-1])
            else:
                temp.append(case[i-1]+case[i+1])
        case = temp[:]
        loop = loop+1
        print(temp)

    stair.append(sum(temp[1:]))
    #0으로 시작하는 값은 없으므로 계단 수 합에서 빼야한다.
    #0번째 값은 동적계획법을 적용하기 위해 임시적으로 넣은 값이다.
    print(stair[len(stair)-1]%1000000000)